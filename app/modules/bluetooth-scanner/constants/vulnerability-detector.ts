// app/modules/bluetooth-scanner/constants/vulnerability-detector.ts
import { BluetoothDevice, DeviceSignature, NetworkDevice } from "../types";
import { DeviceType } from "./service-identifiers";
import { VULNERABILITIES } from "./vulnerabilities";

/**
 * Check device for vulnerabilities based on device type, services, and characteristics
 * @param device The device to check
 * @param deviceSignature Identified device signature (if available)
 * @returns Object containing vulnerability IDs and details
 */
export function checkDeviceVulnerabilities(
  device: BluetoothDevice | NetworkDevice,
  deviceSignature: DeviceSignature | null
): {
  vulnerabilityIds: string[];
  vulnerabilityDetails: string[];
  recommendations: Record<string, string>;
} {
  const vulnerabilityIds: string[] = [];
  const vulnerabilityDetails: string[] = [];

  // Perform checks for Bluetooth devices
  if ("rssi" in device) {
    checkBluetoothVulnerabilities(
      device as BluetoothDevice,
      deviceSignature,
      vulnerabilityIds,
      vulnerabilityDetails
    );
  }

  // Perform checks for network devices
  if ("ipAddress" in device) {
    checkNetworkVulnerabilities(
      device as NetworkDevice,
      deviceSignature,
      vulnerabilityIds,
      vulnerabilityDetails
    );
  }

  // Check for device signature-based vulnerabilities
  if (deviceSignature) {
    checkSignatureVulnerabilities(
      deviceSignature,
      vulnerabilityIds,
      vulnerabilityDetails
    );
  }

  // Generic checks for all devices
  checkGenericVulnerabilities(device, vulnerabilityIds, vulnerabilityDetails);

  // Ensure we have unique vulnerability IDs
  const uniqueVulnerabilityIds = [...new Set(vulnerabilityIds)];

  // Create recommendations object
  const recommendations: Record<string, string> = {};
  uniqueVulnerabilityIds.forEach((id) => {
    if (VULNERABILITIES[id]) {
      recommendations[id] = VULNERABILITIES[id].recommendation;
    }
  });

  return {
    vulnerabilityIds: uniqueVulnerabilityIds,
    vulnerabilityDetails,
    recommendations,
  };
}

/**
 * Check Bluetooth-specific vulnerabilities
 */
function checkBluetoothVulnerabilities(
  device: BluetoothDevice,
  deviceSignature: DeviceSignature | null,
  vulnerabilityIds: string[],
  vulnerabilityDetails: string[]
): void {
  // Skip extensive vulnerability checks for known secure device types
  if (
    deviceSignature &&
    deviceSignature.manufacturer === "Apple" &&
    (deviceSignature.deviceType === DeviceType.LAPTOP ||
      deviceSignature.deviceType === DeviceType.DESKTOP)
  ) {
    // Only perform basic checks for MacBooks and desktops
    // These devices typically have better security protocols
    if (device.isConnectable) {
      vulnerabilityIds.push("BLUEPRINTING");
      vulnerabilityDetails.push(
        "Device is discoverable and may be vulnerable to device fingerprinting"
      );
    }
    return;
  }

  // Device name checks
  if (device.name) {
    const normalizedName = device.name.toLowerCase();

    // Check for devices with default naming patterns
    if (
      normalizedName.includes("headset") ||
      normalizedName.includes("speaker") ||
      normalizedName.includes("watch") ||
      normalizedName.includes("bt") ||
      normalizedName.includes("bose") ||
      normalizedName.includes("soundlink")
    ) {
      vulnerabilityIds.push("BLUEJACKING");
      vulnerabilityDetails.push(
        `Device has a common name "${device.name}" - may be vulnerable to BlueJacking`
      );
    }

    // Check for AIR devices or generic earbuds pattern
    if (
      normalizedName.includes("air-") ||
      normalizedName.includes("tws") ||
      normalizedName.includes("i12")
    ) {
      vulnerabilityIds.push("UNBRANDED_DEVICE");
      vulnerabilityIds.push("WEAK_ENCRYPTION");
      vulnerabilityDetails.push(
        "Generic earbuds often have weak authentication and are vulnerable to attacks"
      );
    }

    // Check for Bose devices which have known vulnerabilities
    if (
      normalizedName.includes("bose") ||
      normalizedName.includes("soundlink")
    ) {
      vulnerabilityIds.push("BLUESNARFING");
      vulnerabilityDetails.push(
        "Bose audio devices can have OBEX vulnerabilities leading to possible BlueSnarfing attacks"
      );
    }
  } else {
    // No name provided - suspicious
    vulnerabilityIds.push("NO_NAME_DEVICE");
    vulnerabilityIds.push("MAC_SPOOFING");
    vulnerabilityDetails.push(
      "Unnamed device could indicate MAC spoofing attempt or device with default settings"
    );
  }

  // Check signal strength for proximity-based attacks
  if (device.rssi !== undefined && device.rssi > -40) {
    vulnerabilityIds.push("BLUEJACKING");
    vulnerabilityDetails.push(
      `Strong signal strength (${device.rssi} dBm) indicates close proximity - potential for close-range attacks`
    );
  }

  // Check for service UUIDs that might indicate vulnerabilities
  if (device.serviceUUIDs && device.serviceUUIDs.length > 0) {
    // Check for OBEX services (vulnerable to BlueSnarfing)
    if (
      device.serviceUUIDs.some(
        (uuid) =>
          uuid.toLowerCase().includes("1105") || // OBEX Object Push
          uuid.toLowerCase().includes("1106") // OBEX File Transfer
      )
    ) {
      vulnerabilityIds.push("BLUESNARFING");
      vulnerabilityDetails.push(
        "Device exposes OBEX services potentially vulnerable to BlueSnarfing attacks"
      );
    }

    // Check for Serial Port Profile (vulnerable to BlueBugging)
    if (
      device.serviceUUIDs.some(
        (uuid) => uuid.toLowerCase().includes("1101") // Serial Port
      )
    ) {
      vulnerabilityIds.push("BLUEBUGGING");
      vulnerabilityDetails.push(
        "Device exposes Serial Port Profile potentially vulnerable to BlueBugging attacks"
      );
    }

    // Check for older Bluetooth services indicating potential weaknesses
    if (
      device.serviceUUIDs.some(
        (uuid) =>
          uuid.toLowerCase().includes("1124") || // HID
          uuid.toLowerCase().includes("1200") // PnP Information
      )
    ) {
      // Skip this check for macOS devices which legitimately use these services
      if (
        !(
          deviceSignature &&
          deviceSignature.manufacturer === "Apple" &&
          deviceSignature.deviceType === DeviceType.LAPTOP
        )
      ) {
        vulnerabilityIds.push("REFLECTION");
        vulnerabilityIds.push("MITM");
        vulnerabilityDetails.push(
          "Device uses older Bluetooth services that may be vulnerable to Man-in-the-Middle attacks"
        );
      }
    }
  }

  // Skip authentication check for computers that are in discovery mode
  const isComputer =
    deviceSignature &&
    (deviceSignature.deviceType === DeviceType.LAPTOP ||
      deviceSignature.deviceType === DeviceType.DESKTOP);

  // Check if device is connectable but not using secure simple pairing
  if (
    device.isConnectable &&
    (!device.bondState || device.bondState === "none") &&
    !isComputer
  ) {
    vulnerabilityIds.push("MISSING_AUTHENTICATION");
    vulnerabilityDetails.push(
      "Device is connectable without requiring secure pairing/bonding"
    );
  }

  // Check for Bluetooth LE tracking vulnerabilities based on MAC address
  // (Devices that don't use random MAC addresses can be tracked)
  if (
    device.id &&
    !device.id.includes("random") &&
    device.advertising?.isConnectable &&
    // Skip this check for computers in discovery mode which are expected to be discoverable
    !isComputer
  ) {
    vulnerabilityIds.push("BLUETOOTH_LE_TRACKING");
    vulnerabilityDetails.push(
      "Device may be vulnerable to tracking via static Bluetooth LE address"
    );
  }
}

/**
 * Check network device-specific vulnerabilities
 */
function checkNetworkVulnerabilities(
  device: NetworkDevice,
  deviceSignature: DeviceSignature | null,
  vulnerabilityIds: string[],
  vulnerabilityDetails: string[]
): void {
  // Skip extensive checks for known secure device types
  if (
    deviceSignature &&
    deviceSignature.manufacturer === "Apple" &&
    (deviceSignature.deviceType === DeviceType.LAPTOP ||
      deviceSignature.deviceType === DeviceType.DESKTOP)
  ) {
    // Only add minimal vulnerability info for Apple computers
    vulnerabilityIds.push("MDNS_INFORMATION_DISCLOSURE");
    vulnerabilityDetails.push(
      "Device is broadcasting on the local network via mDNS"
    );
    return;
  }

  // Check for mDNS information disclosure
  if (device.serviceTypes && device.serviceTypes.length > 0) {
    // Check for potentially sensitive service types
    const sensitiveServices = device.serviceTypes.filter(
      (service) =>
        service.includes("_ssh") ||
        service.includes("_ftp") ||
        service.includes("_printer") ||
        service.includes("_device-info")
    );

    if (sensitiveServices.length > 0) {
      vulnerabilityIds.push("MDNS_INFORMATION_DISCLOSURE");
      vulnerabilityDetails.push(
        `Device is broadcasting sensitive services via mDNS: ${sensitiveServices.join(
          ", "
        )}`
      );
    }

    // Check for insecure protocols
    const insecureServices = device.serviceTypes.filter(
      (service) =>
        service.includes("_telnet") ||
        service.includes("_ftp._tcp") ||
        service.includes("_http._tcp")
    );

    if (insecureServices.length > 0) {
      vulnerabilityIds.push("INSECURE_PROTOCOLS");
      vulnerabilityDetails.push(
        `Device is using insecure protocols: ${insecureServices.join(", ")}`
      );
    }

    // Check for UPnP
    if (device.serviceTypes.some((service) => service.includes("_upnp"))) {
      vulnerabilityIds.push("UPnP_ENABLED");
      vulnerabilityDetails.push(
        "Device has UPnP enabled which may expose it to network attacks"
      );
    }
  }

  // Check for default/common hostnames indicating default configurations
  if (device.hostName) {
    const normalizedHostName = device.hostName.toLowerCase();
    if (
      normalizedHostName.includes("admin") ||
      normalizedHostName.includes("default") ||
      normalizedHostName.includes("router") ||
      normalizedHostName.includes("wireless") ||
      normalizedHostName.includes("gateway")
    ) {
      vulnerabilityIds.push("DEFAULT_CREDENTIALS");
      vulnerabilityDetails.push(
        `Device has a default/common hostname "${device.hostName}" which may indicate default credentials`
      );
    }
  }
}

/**
 * Check vulnerabilities based on identified device signature
 */
function checkSignatureVulnerabilities(
  deviceSignature: DeviceSignature,
  vulnerabilityIds: string[],
  vulnerabilityDetails: string[]
): void {
  // Skip vulnerability checks for certain trusted devices
  const isAppleComputer =
    deviceSignature.manufacturer === "Apple" &&
    (deviceSignature.deviceType === DeviceType.LAPTOP ||
      deviceSignature.deviceType === DeviceType.DESKTOP);

  if (isAppleComputer) {
    // Only add minimal vulnerability info for Apple computers
    vulnerabilityIds.push("BLUEPRINTING");
    vulnerabilityDetails.push(
      "Device is identifiable through Bluetooth scanning"
    );
    return;
  }

  // Check if device has known vulnerabilities
  if (
    deviceSignature.vulnerableVersions &&
    deviceSignature.vulnerableVersions.includes("*")
  ) {
    vulnerabilityIds.push("UNBRANDED_DEVICE");
    vulnerabilityIds.push("WEAK_ENCRYPTION");
    vulnerabilityDetails.push(
      `${deviceSignature.manufacturer} ${deviceSignature.model} has known security weaknesses`
    );

    if (deviceSignature.recommendedFirmware) {
      vulnerabilityDetails.push(
        `Recommendation: ${deviceSignature.recommendedFirmware}`
      );
    }
  }

  // Device type specific vulnerabilities
  if (
    deviceSignature.deviceType === DeviceType.EARBUDS &&
    deviceSignature.manufacturer === "Unknown"
  ) {
    vulnerabilityIds.push("MISSING_AUTHENTICATION");
    vulnerabilityDetails.push(
      "Generic earbuds typically lack secure authentication"
    );
  }

  // Add manufacturer-specific details
  if (deviceSignature.manufacturer === "Bose") {
    vulnerabilityIds.push("BLUESNARFING");
    vulnerabilityDetails.push(
      `${deviceSignature.model} devices have been found vulnerable to BlueSnarfing attacks`
    );
  }

  // Add specific vulnerabilities for Olympus cameras
  if (
    deviceSignature.manufacturer === "Olympus" &&
    deviceSignature.deviceType === DeviceType.CAMERA
  ) {
    vulnerabilityIds.push("WEAK_ENCRYPTION");
    vulnerabilityIds.push("UNENCRYPTED_COMMUNICATION");
    vulnerabilityIds.push("OUTDATED_FIRMWARE");
    vulnerabilityDetails.push(
      "Olympus AIR cameras are known to have weak encryption and may transmit data without proper security"
    );
  }

  // Add specific vulnerabilities for Microsoft devices
  if (deviceSignature.manufacturer === "Microsoft") {
    vulnerabilityIds.push("BLUETOOTH_LE_TRACKING");
    vulnerabilityDetails.push(
      "Microsoft devices may broadcast identifiable information"
    );
  }

  // Check for smart home device vulnerabilities
  if (
    deviceSignature.deviceType === DeviceType.SMART_HOME_HUB ||
    deviceSignature.deviceType === DeviceType.SMART_LIGHT ||
    deviceSignature.deviceType === DeviceType.SMART_PLUG
  ) {
    vulnerabilityIds.push("INSECURE_PROTOCOLS");
    vulnerabilityIds.push("UPnP_ENABLED");
    vulnerabilityDetails.push(
      "Smart home devices often use insecure protocols and may expose sensitive information"
    );
  }

  // Router/IoT vulnerabilities
  if (
    deviceSignature.deviceType === DeviceType.ROUTER ||
    deviceSignature.deviceType === DeviceType.ACCESS_POINT
  ) {
    vulnerabilityIds.push("DEFAULT_CREDENTIALS");
    vulnerabilityIds.push("UPnP_ENABLED");
    vulnerabilityIds.push("INSECURE_PROTOCOLS");
    vulnerabilityDetails.push(
      "Network devices are frequently left with default credentials and insecure settings"
    );
  }
}

/**
 * Generic vulnerability checks for all devices
 */
function checkGenericVulnerabilities(
  device: BluetoothDevice | NetworkDevice,
  vulnerabilityIds: string[],
  vulnerabilityDetails: string[]
): void {
  // Check for generic vulnerabilities based on device name patterns
  const deviceName = device.name?.toLowerCase() || "";

  // Skip certain checks for Apple MacBooks
  if (
    deviceName.includes("macbook") ||
    (deviceName.includes("mac") && deviceName.includes("pro"))
  ) {
    // MacBooks are generally less vulnerable, so just add basic info
    return;
  }

  // Check for devices with versions in their names that might be outdated
  if (
    deviceName.includes("v1.") ||
    deviceName.includes("v2.") ||
    deviceName.includes(" old") ||
    deviceName.includes("2015") ||
    deviceName.includes("2016") ||
    deviceName.includes("2017") ||
    deviceName.includes("2018")
  ) {
    vulnerabilityIds.push("OUTDATED_FIRMWARE");
    vulnerabilityDetails.push(
      "Device name suggests it may be running outdated firmware"
    );
  }

  // No name is suspicious for any device type
  if (!device.name || device.name.trim() === "") {
    vulnerabilityIds.push("NO_NAME_DEVICE");
    vulnerabilityDetails.push(
      "Unnamed device increases difficulty in identification and may indicate spoofing attempts"
    );
  }
}

/**
 * Calculate security score based on vulnerabilities
 * @param device The device to score
 * @param vulnerabilityIds Identified vulnerability IDs
 * @returns Security score (0-100)
 */
export function calculateSecurityScore(
  device: BluetoothDevice | NetworkDevice,
  vulnerabilityIds: string[]
): number {
  // Start with perfect score
  let score = 100;

  // Give higher base scores to certain device types that are generally more secure
  const deviceName = device.name?.toLowerCase() || "";
  if (deviceName.includes("macbook") || deviceName.includes("mac pro")) {
    // Apple computers start with higher baseline security
    score = 95; // Only deduct 5 points by default for being discoverable

    // Only count critical vulnerabilities for MacBooks
    vulnerabilityIds.forEach((id) => {
      const vulnerability = VULNERABILITIES[id];
      if (vulnerability && vulnerability.severity === "critical") {
        score -= 15; // Reduced impact even for critical vulnerabilities
      }
    });

    return Math.max(60, score); // Minimum score of 60 for Apple computers
  }

  // Standard scoring for other devices
  // Deduct points for each vulnerability based on severity
  vulnerabilityIds.forEach((id) => {
    const vulnerability = VULNERABILITIES[id];
    if (vulnerability) {
      switch (vulnerability.severity) {
        case "critical":
          score -= 25;
          break;
        case "high":
          score -= 15;
          break;
        case "medium":
          score -= 10;
          break;
        case "low":
          score -= 5;
          break;
      }
    }
  });

  // Additional deductions for Bluetooth devices
  if ("rssi" in device) {
    const btDevice = device as BluetoothDevice;

    // Deduct points for weak signal (less reliable assessment)
    if (btDevice.rssi < -80) {
      score -= 5;
    }
  }

  // Additional deductions for network devices
  if ("ipAddress" in device) {
    // No additional deductions for now
  }

  // No name could indicate suspicious device
  if (!device.name) {
    score -= 5;
  }

  // Ensure score stays in 0-100 range
  return Math.max(0, Math.min(100, score));
}

export default {};
