// app/modules/bluetooth-scanner/constants/vulnerability-detector.ts
import { BluetoothDevice, DeviceSignature, NetworkDevice } from "../types";
import { DeviceType } from "./service-identifiers";
import { VULNERABILITIES } from "./vulnerabilities";

/**
 * Check device for vulnerabilities based on device type, services, and characteristics
 * @param device The device to check
 * @param deviceSignature Identified device signature (if available)
 * @returns Object containing vulnerability IDs and details
 */
export function checkDeviceVulnerabilities(
  device: BluetoothDevice | NetworkDevice,
  deviceSignature: DeviceSignature | null
): {
  vulnerabilityIds: string[];
  vulnerabilityDetails: string[];
} {
  const vulnerabilityIds: string[] = [];
  const vulnerabilityDetails: string[] = [];

  // Perform checks for Bluetooth devices
  if ("rssi" in device) {
    checkBluetoothVulnerabilities(
      device as BluetoothDevice,
      deviceSignature,
      vulnerabilityIds,
      vulnerabilityDetails
    );
  }

  // Perform checks for network devices
  if ("ipAddress" in device) {
    checkNetworkVulnerabilities(
      device as NetworkDevice,
      deviceSignature,
      vulnerabilityIds,
      vulnerabilityDetails
    );
  }

  // Check for device signature-based vulnerabilities
  if (deviceSignature) {
    checkSignatureVulnerabilities(
      deviceSignature,
      vulnerabilityIds,
      vulnerabilityDetails
    );
  }

  // Generic checks for all devices
  checkGenericVulnerabilities(device, vulnerabilityIds, vulnerabilityDetails);

  // Ensure we have unique vulnerability IDs
  const uniqueVulnerabilityIds = [...new Set(vulnerabilityIds)];

  return {
    vulnerabilityIds: uniqueVulnerabilityIds,
    vulnerabilityDetails,
  };
}

/**
 * Check Bluetooth-specific vulnerabilities
 */
function checkBluetoothVulnerabilities(
  device: BluetoothDevice,
  deviceSignature: DeviceSignature | null,
  vulnerabilityIds: string[],
  vulnerabilityDetails: string[]
): void {
  // Device name checks
  if (device.name) {
    const normalizedName = device.name.toLowerCase();

    // Check for devices with default naming patterns
    if (
      normalizedName.includes("headset") ||
      normalizedName.includes("speaker") ||
      normalizedName.includes("watch") ||
      normalizedName.includes("bt") ||
      normalizedName.includes("bose") ||
      normalizedName.includes("soundlink")
    ) {
      vulnerabilityIds.push("BLUEJACKING");
      vulnerabilityDetails.push(
        `Device has a default name "${device.name}" - may be vulnerable to BlueJacking`
      );
    }

    // Check for AIR devices or generic earbuds pattern
    if (
      normalizedName.includes("air-") ||
      normalizedName.includes("tws") ||
      normalizedName.includes("i12")
    ) {
      vulnerabilityIds.push("UNBRANDED_DEVICE");
      vulnerabilityIds.push("WEAK_ENCRYPTION");
      vulnerabilityDetails.push(
        "Generic earbuds often have weak authentication and are vulnerable to attacks"
      );
    }

    // Check for Bose devices which have known vulnerabilities
    if (
      normalizedName.includes("bose") ||
      normalizedName.includes("soundlink")
    ) {
      vulnerabilityIds.push("BLUESNARFING");
      vulnerabilityDetails.push(
        "Bose audio devices can have OBEX vulnerabilities leading to possible BlueSnarfing attacks"
      );
    }
  } else {
    // No name provided - suspicious
    vulnerabilityIds.push("NO_NAME_DEVICE");
    vulnerabilityIds.push("MAC_SPOOFING");
    vulnerabilityDetails.push(
      "Unnamed device could indicate MAC spoofing attempt or device with default settings"
    );
  }

  // Check signal strength for proximity-based attacks
  if (device.rssi !== undefined && device.rssi > -40) {
    vulnerabilityIds.push("BLUEJACKING");
    vulnerabilityDetails.push(
      `Strong signal strength (${device.rssi} dBm) indicates close proximity - potential for close-range attacks`
    );
  }

  // Check for service UUIDs that might indicate vulnerabilities
  if (device.serviceUUIDs && device.serviceUUIDs.length > 0) {
    // Check for OBEX services (vulnerable to BlueSnarfing)
    if (
      device.serviceUUIDs.some(
        (uuid) =>
          uuid.toLowerCase().includes("1105") || // OBEX Object Push
          uuid.toLowerCase().includes("1106") // OBEX File Transfer
      )
    ) {
      vulnerabilityIds.push("BLUESNARFING");
      vulnerabilityDetails.push(
        "Device exposes OBEX services potentially vulnerable to BlueSnarfing attacks"
      );
    }

    // Check for Serial Port Profile (vulnerable to BlueBugging)
    if (
      device.serviceUUIDs.some(
        (uuid) => uuid.toLowerCase().includes("1101") // Serial Port
      )
    ) {
      vulnerabilityIds.push("BLUEBUGGING");
      vulnerabilityDetails.push(
        "Device exposes Serial Port Profile potentially vulnerable to BlueBugging attacks"
      );
    }

    // Check for older Bluetooth services indicating potential weaknesses
    if (
      device.serviceUUIDs.some(
        (uuid) =>
          uuid.toLowerCase().includes("1124") || // HID
          uuid.toLowerCase().includes("1200") // PnP Information
      )
    ) {
      vulnerabilityIds.push("REFLECTION");
      vulnerabilityIds.push("MITM");
      vulnerabilityDetails.push(
        "Device uses older Bluetooth services that may be vulnerable to Man-in-the-Middle attacks"
      );
    }
  }

  // Check if device is connectable but not using secure simple pairing
  if (
    device.isConnectable &&
    (!device.bondState || device.bondState === "none")
  ) {
    vulnerabilityIds.push("MISSING_AUTHENTICATION");
    vulnerabilityDetails.push(
      "Device is connectable without requiring secure pairing/bonding"
    );
  }

  // Check for Bluetooth LE tracking vulnerabilities based on MAC address
  // (Devices that don't use random MAC addresses can be tracked)
  if (
    device.id &&
    !device.id.includes("random") &&
    device.advertising?.isConnectable
  ) {
    vulnerabilityIds.push("BLUETOOTH_LE_TRACKING");
    vulnerabilityDetails.push(
      "Device may be vulnerable to tracking via static Bluetooth LE address"
    );
  }
}

/**
 * Check network device-specific vulnerabilities
 */
function checkNetworkVulnerabilities(
  device: NetworkDevice,
  deviceSignature: DeviceSignature | null,
  vulnerabilityIds: string[],
  vulnerabilityDetails: string[]
): void {
  // Check for mDNS information disclosure
  if (device.serviceTypes && device.serviceTypes.length > 0) {
    // Check for potentially sensitive service types
    const sensitiveServices = device.serviceTypes.filter(
      (service) =>
        service.includes("_ssh") ||
        service.includes("_ftp") ||
        service.includes("_printer") ||
        service.includes("_device-info")
    );

    if (sensitiveServices.length > 0) {
      vulnerabilityIds.push("MDNS_INFORMATION_DISCLOSURE");
      vulnerabilityDetails.push(
        `Device is broadcasting sensitive services via mDNS: ${sensitiveServices.join(
          ", "
        )}`
      );
    }

    // Check for insecure protocols
    const insecureServices = device.serviceTypes.filter(
      (service) =>
        service.includes("_telnet") ||
        service.includes("_ftp._tcp") ||
        service.includes("_http._tcp")
    );

    if (insecureServices.length > 0) {
      vulnerabilityIds.push("INSECURE_PROTOCOLS");
      vulnerabilityDetails.push(
        `Device is using insecure protocols: ${insecureServices.join(", ")}`
      );
    }

    // Check for UPnP
    if (device.serviceTypes.some((service) => service.includes("_upnp"))) {
      vulnerabilityIds.push("UPnP_ENABLED");
      vulnerabilityDetails.push(
        "Device has UPnP enabled which may expose it to network attacks"
      );
    }
  }

  // Check for default/common hostnames indicating default configurations
  if (device.hostName) {
    const normalizedHostName = device.hostName.toLowerCase();
    if (
      normalizedHostName.includes("admin") ||
      normalizedHostName.includes("default") ||
      normalizedHostName.includes("router") ||
      normalizedHostName.includes("wireless") ||
      normalizedHostName.includes("gateway")
    ) {
      vulnerabilityIds.push("DEFAULT_CREDENTIALS");
      vulnerabilityDetails.push(
        `Device has a default/common hostname "${device.hostName}" which may indicate default credentials`
      );
    }
  }
}

/**
 * Check vulnerabilities based on identified device signature
 */
function checkSignatureVulnerabilities(
  deviceSignature: DeviceSignature,
  vulnerabilityIds: string[],
  vulnerabilityDetails: string[]
): void {
  // Check if device has known vulnerabilities
  if (
    deviceSignature.vulnerableVersions &&
    deviceSignature.vulnerableVersions.includes("*")
  ) {
    vulnerabilityIds.push("UNBRANDED_DEVICE");
    vulnerabilityIds.push("WEAK_ENCRYPTION");
    vulnerabilityDetails.push(
      `${deviceSignature.manufacturer} ${deviceSignature.model} has known security weaknesses`
    );

    if (deviceSignature.recommendedFirmware) {
      vulnerabilityDetails.push(
        `Recommendation: ${deviceSignature.recommendedFirmware}`
      );
    }
  }

  // Device type specific vulnerabilities
  if (
    deviceSignature.deviceType === DeviceType.EARBUDS &&
    deviceSignature.manufacturer === "Unknown"
  ) {
    vulnerabilityIds.push("MISSING_AUTHENTICATION");
    vulnerabilityDetails.push(
      "Generic earbuds typically lack secure authentication"
    );
  }

  // Add manufacturer-specific details
  if (deviceSignature.manufacturer === "Bose") {
    vulnerabilityIds.push("BLUESNARFING");
    vulnerabilityDetails.push(
      `${deviceSignature.model} devices have been found vulnerable to BlueSnarfing attacks`
    );
  }

  // Check for smart home device vulnerabilities
  if (
    deviceSignature.deviceType === DeviceType.SMART_HOME_HUB ||
    deviceSignature.deviceType === DeviceType.SMART_LIGHT ||
    deviceSignature.deviceType === DeviceType.SMART_PLUG
  ) {
    vulnerabilityIds.push("INSECURE_PROTOCOLS");
    vulnerabilityIds.push("UPnP_ENABLED");
    vulnerabilityDetails.push(
      "Smart home devices often use insecure protocols and may expose sensitive information"
    );
  }

  // Router/IoT vulnerabilities
  if (
    deviceSignature.deviceType === DeviceType.ROUTER ||
    deviceSignature.deviceType === DeviceType.ACCESS_POINT
  ) {
    vulnerabilityIds.push("DEFAULT_CREDENTIALS");
    vulnerabilityIds.push("UPnP_ENABLED");
    vulnerabilityIds.push("INSECURE_PROTOCOLS");
    vulnerabilityDetails.push(
      "Network devices are frequently left with default credentials and insecure settings"
    );
  }
}

/**
 * Generic vulnerability checks for all devices
 */
function checkGenericVulnerabilities(
  device: BluetoothDevice | NetworkDevice,
  vulnerabilityIds: string[],
  vulnerabilityDetails: string[]
): void {
  // Check for generic vulnerabilities based on device name patterns
  const deviceName = device.name?.toLowerCase() || "";

  // Check for devices with versions in their names that might be outdated
  if (
    deviceName.includes("v1.") ||
    deviceName.includes("v2.") ||
    deviceName.includes(" old") ||
    deviceName.includes("2015") ||
    deviceName.includes("2016") ||
    deviceName.includes("2017") ||
    deviceName.includes("2018")
  ) {
    vulnerabilityIds.push("OUTDATED_FIRMWARE");
    vulnerabilityDetails.push(
      "Device name suggests it may be running outdated firmware"
    );
  }

  // No name is suspicious for any device type
  if (!device.name || device.name.trim() === "") {
    vulnerabilityIds.push("NO_NAME_DEVICE");
    vulnerabilityDetails.push(
      "Unnamed device increases difficulty in identification and may indicate spoofing attempts"
    );
  }
}

/**
 * Calculate security score based on vulnerabilities
 * @param device The device to score
 * @param vulnerabilityIds Identified vulnerability IDs
 * @returns Security score (0-100)
 */
export function calculateSecurityScore(
  device: BluetoothDevice | NetworkDevice,
  vulnerabilityIds: string[]
): number {
  // Start with perfect score
  let score = 100;

  // Deduct points for each vulnerability based on severity
  vulnerabilityIds.forEach((id) => {
    const vulnerability = VULNERABILITIES[id];
    if (vulnerability) {
      switch (vulnerability.severity) {
        case "critical":
          score -= 25;
          break;
        case "high":
          score -= 15;
          break;
        case "medium":
          score -= 10;
          break;
        case "low":
          score -= 5;
          break;
      }
    }
  });

  // Additional deductions for Bluetooth devices
  if ("rssi" in device) {
    const btDevice = device as BluetoothDevice;

    // Deduct points for weak signal (less reliable assessment)
    if (btDevice.rssi < -80) {
      score -= 5;
    }
  }

  // Additional deductions for network devices
  if ("ipAddress" in device) {
    // No additional deductions for now
  }

  // No name could indicate suspicious device
  if (!device.name) {
    score -= 5;
  }

  // Ensure score stays in 0-100 range
  return Math.max(0, Math.min(100, score));
}

export default {};
